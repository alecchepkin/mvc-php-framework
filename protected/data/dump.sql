/*
 Navicat Premium Data Transfer

 Source Server         : localhost
 Source Server Type    : MySQL
 Source Server Version : 50621
 Source Host           : localhost
 Source Database       : blogtest

 Target Server Type    : MySQL
 Target Server Version : 50621
 File Encoding         : utf-8

 Date: 10/29/2014 22:39:25 PM
*/

SET NAMES utf8;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
--  Table structure for `post`
-- ----------------------------
DROP TABLE IF EXISTS `post`;
CREATE TABLE `post` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(50) DEFAULT NULL,
  `body` text,
  `date_created` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=24 DEFAULT CHARSET=utf8;

-- ----------------------------
--  Records of `post`
-- ----------------------------
BEGIN;
INSERT INTO `post` VALUES ('18', 'gitignore - Specifies intentionally untracked file', 'A gitignore file specifies intentionally untracked files that Git should ignore. Files already tracked by Git are not affected; see the NOTES below for details.\r\n\r\nEach line in a gitignore file specifies a pattern. When deciding whether to ignore a path, Git normally checks gitignore patterns from multiple sources, with the following order of precedence, from highest to lowest (within one level of precedence, the last matching pattern decides the outcome):\r\n\r\nPatterns read from the command line for those commands that support them.\r\n\r\nPatterns read from a .gitignore file in the same directory as the path, or in any parent directory, with patterns in the higher level files (up to the toplevel of the work tree) being overridden by those in lower level files down to the directory containing the file. These patterns match relative to the location of the .gitignore file. A project normally includes such .gitignore files in its repository, containing patterns for files generated as part of the project build.\r\n\r\nPatterns read from $GIT_DIR/info/exclude.\r\n\r\nPatterns read from the file specified by the configuration variable core.excludesfile.\r\n\r\nWhich file to place a pattern in depends on how the pattern is meant to be used.', '2014-10-16 02:13:37'), ('19', 'Getting Started - Installing Git', 'Installing Git\r\nLetâ€™s get into using some Git. First things firstâ€”you have to install it. You can get it a number of ways; the two major ones are to install it from source or to install an existing package for your platform.\r\n\r\nInstalling from Source\r\nIf you can, itâ€™s generally useful to install Git from source, because youâ€™ll get the most recent version. Each version of Git tends to include useful UI enhancements, so getting the latest version is often the best route if you feel comfortable compiling software from source. It is also the case that many Linux distributions contain very old packages; so unless youâ€™re on a very up-to-date distro or are using backports, installing from source may be the best bet.\r\n\r\nTo install Git, you need to have the following libraries that Git depends on: curl, zlib, openssl, expat, and libiconv. For example, if youâ€™re on a system that has yum (such as Fedora) or apt-get (such as a Debian based system), you can use one of these commands to install all of the dependencies:\r\n\r\n$ yum install curl-devel expat-devel gettext-devel \\\r\n  openssl-devel zlib-devel\r\n\r\n$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\\r\n  libz-dev libssl-dev\r\nWhen you have all the necessary dependencies, you can go ahead and grab the latest snapshot from the Git web site:\r\n\r\nhttp://git-scm.com/download\r\nThen, compile and install:\r\n\r\n$ tar -zxf git-1.7.2.2.tar.gz\r\n$ cd git-1.7.2.2\r\n$ make prefix=/usr/local all\r\n$ sudo make prefix=/usr/local install\r\nAfter this is done, you can also get Git via Git itself for updates:\r\n\r\n$ git clone git://git.kernel.org/pub/scm/git/git.git\r\nInstalling on Linux\r\nIf you want to install Git on Linux via a binary installer, you can generally do so through the basic package-management tool that comes with your distribution. If youâ€™re on Fedora, you can use yum:\r\n\r\n$ yum install git\r\nOr if youâ€™re on a Debian-based distribution like Ubuntu, try apt-get:\r\n\r\n$ apt-get install git\r\nInstalling on Mac\r\nThere are three easy ways to install Git on a Mac. The easiest is to use the graphical Git installer, which you can download from the SourceForge page (see Figure 1-7):', '2014-10-16 02:14:13'), ('20', 'Getting Started - A Short History of Git', 'A Short History of Git\r\nAs with many great things in life, Git began with a bit of creative destruction and fiery controversy. The Linux kernel is an open source software project of fairly large scope. For most of the lifetime of the Linux kernel maintenance (1991â€“2002), changes to the software were passed around as patches and archived files. In 2002, the Linux kernel project began using a proprietary DVCS system called BitKeeper.\r\n\r\nIn 2005, the relationship between the community that developed the Linux kernel and the commercial company that developed BitKeeper broke down, and the toolâ€™s free-of-charge status was revoked. This prompted the Linux development community (and in particular Linus Torvalds, the creator of Linux) to develop their own tool based on some of the lessons they learned while using BitKeeper. Some of the goals of the new system were as follows:\r\n\r\nSpeed\r\nSimple design\r\nStrong support for non-linear development (thousands of parallel branches)\r\nFully distributed\r\nAble to handle large projects like the Linux kernel efficiently (speed and data size)\r\nSince its birth in 2005, Git has evolved and matured to be easy to use and yet retain these initial qualities. Itâ€™s incredibly fast, itâ€™s very efficient with large projects, and it has an incredible branching system for non-linear development (See Chapter 3).', '2014-10-16 02:14:42'), ('21', 'Git on the Server - Generating Your SSH Public Key', 'Generating Your SSH Public Key\r\nThat being said, many Git servers authenticate using SSH public keys. In order to provide a public key, each user in your system must generate one if they donâ€™t already have one. This process is similar across all operating systems. First, you should check to make sure you donâ€™t already have a key. By default, a userâ€™s SSH keys are stored in that userâ€™s ~/.ssh directory. You can easily check to see if you have a key already by going to that directory and listing the contents:\r\n\r\n$ cd ~/.ssh\r\n$ ls\r\nauthorized_keys2  id_dsa       known_hosts\r\nconfig            id_dsa.pub\r\nYouâ€™re looking for a pair of files named something and something.pub, where the something is usually id_dsa or id_rsa. The .pub file is your public key, and the other file is your private key. If you donâ€™t have these files (or you donâ€™t even have a .ssh directory), you can create them by running a program called ssh-keygen, which is provided with the SSH package on Linux/Mac systems and comes with the MSysGit package on Windows:\r\n\r\n$ ssh-keygen\r\nGenerating public/private rsa key pair.\r\nEnter file in which to save the key (/Users/schacon/.ssh/id_rsa):\r\nEnter passphrase (empty for no passphrase):\r\nEnter same passphrase again:\r\nYour identification has been saved in /Users/schacon/.ssh/id_rsa.\r\nYour public key has been saved in /Users/schacon/.ssh/id_rsa.pub.\r\nThe key fingerprint is:\r\n43:c5:5b:5f:b1:f1:50:43:ad:20:a6:92:6a:1f:9a:3a schacon@agadorlaptop.local\r\nFirst it confirms where you want to save the key (.ssh/id_rsa), and then it asks twice for a passphrase, which you can leave empty if you donâ€™t want to type a password when you use the key.\r\n\r\nNow, each user that does this has to send their public key to you or whoever is administrating the Git server (assuming youâ€™re using an SSH server setup that requires public keys). All they have to do is copy the contents of the .pub file and e-mail it. The public keys look something like this:\r\n\r\n$ cat ~/.ssh/id_rsa.pub\r\nssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU\r\nGPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3\r\nPbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA\r\nt3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En\r\nmZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx\r\nNrRFi9wrf+M7Q== schacon@agadorlaptop.local\r\nFor a more in-depth tutorial on creating an SSH key on multiple operating systems, see the GitHub guide on SSH keys at http://github.com/guides/providing-your-ssh-key.', '2014-10-16 02:15:23'), ('22', 'Git Branching - Branch Management', 'Branch Management\r\nNow that youâ€™ve created, merged, and deleted some branches, letâ€™s look at some branch-management tools that will come in handy when you begin using branches all the time.\r\n\r\nThe git branch command does more than just create and delete branches. If you run it with no arguments, you get a simple listing of your current branches:\r\n\r\n$ git branch\r\n  iss53\r\n* master\r\n  testing\r\nNotice the * character that prefixes the master branch: it indicates the branch that you currently have checked out. This means that if you commit at this point, the master branch will be moved forward with your new work. To see the last commit on each branch, you can run git branch -v:\r\n\r\n$ git branch -v\r\n  iss53   93b412c fix javascript issue\r\n* master  7a98805 Merge branch \'iss53\'\r\n  testing 782fd34 add scott to the author list in the readmes\r\nAnother useful option to figure out what state your branches are in is to filter this list to branches that you have or have not yet merged into the branch youâ€™re currently on. There are useful --merged and --no-merged options available in Git for this purpose. To see which branches are already merged into the branch youâ€™re on, you can run git branch --merged:\r\n\r\n$ git branch --merged\r\n  iss53\r\n* master\r\nBecause you already merged in iss53 earlier, you see it in your list. Branches on this list without the * in front of them are generally fine to delete with git branch -d; youâ€™ve already incorporated their work into another branch, so youâ€™re not going to lose anything.\r\n\r\nTo see all the branches that contain work you havenâ€™t yet merged in, you can run git branch --no-merged:\r\n\r\n$ git branch --no-merged\r\n  testing\r\nThis shows your other branch. Because it contains work that isnâ€™t merged in yet, trying to delete it with git branch -d will fail:\r\n\r\n$ git branch -d testing\r\nerror: The branch \'testing\' is not fully merged.\r\nIf you are sure you want to delete it, run \'git branch -D testing\'.\r\nIf you really do want to delete the branch and lose that work, you can force it with -D, as the helpful message points out.\r\n', '2014-10-16 02:15:52'), ('23', 'Git Branching - Branching Workflows', 'Branching Workflows\r\nNow that you have the basics of branching and merging down, what can or should you do with them? In this section, weâ€™ll cover some common workflows that this lightweight branching makes possible, so you can decide if you would like to incorporate it into your own development cycle.\r\n\r\nLong-Running Branches\r\nBecause Git uses a simple three-way merge, merging from one branch into another multiple times over a long period is generally easy to do. This means you can have several branches that are always open and that you use for different stages of your development cycle; you can merge regularly from some of them into others.\r\n\r\nMany Git developers have a workflow that embraces this approach, such as having only code that is entirely stable in their master branch â€” possibly only code that has been or will be released. They have another parallel branch named develop or next that they work from or use to test stability â€” it isnâ€™t necessarily always stable, but whenever it gets to a stable state, it can be merged into master. Itâ€™s used to pull in topic branches (short-lived branches, like your earlier iss53 branch) when theyâ€™re ready, to make sure they pass all the tests and donâ€™t introduce bugs.\r\n\r\nIn reality, weâ€™re talking about pointers moving up the line of commits youâ€™re making. The stable branches are farther down the line in your commit history, and the bleeding-edge branches are farther up the history (see Figure 3-18).\r\n\r\n\r\n\r\nFigure 3-18. More stable branches are generally farther down the commit history.\r\nItâ€™s generally easier to think about them as work silos, where sets of commits graduate to a more stable silo when theyâ€™re fully tested (see Figure 3-19).\r\n\r\n\r\n\r\nFigure 3-19. It may be helpful to think of your branches as silos.\r\nYou can keep doing this for several levels of stability. Some larger projects also have a proposed or pu (proposed updates) branch that has integrated branches that may not be ready to go into the next or master branch. The idea is that your branches are at various levels of stability; when they reach a more stable level, theyâ€™re merged into the branch above them. Again, having multiple long-running branches isnâ€™t necessary, but itâ€™s often helpful, especially when youâ€™re dealing with very large or complex projects.\r\n\r\nTopic Branches\r\nTopic branches, however, are useful in projects of any size. A topic branch is a short-lived branch that you create and use for a single particular feature or related work. This is something youâ€™ve likely never done with a VCS before because itâ€™s generally too expensive to create and merge branches. But in Git itâ€™s common to create, work on, merge, and delete branches several times a day.\r\n\r\nYou saw this in the last section with the iss53 and hotfix branches you created. You did a few commits on them and deleted them directly after merging them into your main branch. This technique allows you to context-switch quickly and completely â€” because your work is separated into silos where all the changes in that branch have to do with that topic, itâ€™s easier to see what has happened during code review and such. You can keep the changes there for minutes, days, or months, and merge them in when theyâ€™re ready, regardless of the order in which they were created or worked on.\r\n\r\nConsider an example of doing some work (on master), branching off for an issue (iss91), working on it for a bit, branching off the second branch to try another way of handling the same thing (iss91v2), going back to your master branch and working there for a while, and then branching off there to do some work that youâ€™re not sure is a good idea (dumbidea branch). Your commit history will look something like Figure 3-20.\r\n\r\n\r\n\r\nFigure 3-20. Your commit history with multiple topic branches.\r\nNow, letâ€™s say you decide you like the second solution to your issue best (iss91v2); and you showed the dumbidea branch to your coworkers, and it turns out to be genius. You can throw away the original iss91 branch (losing commits C5 and C6) and merge in the other two. Your history then looks like Figure 3-21.\r\n\r\n\r\n\r\nFigure 3-21. Your history after merging in dumbidea and iss91v2.\r\nItâ€™s important to remember when youâ€™re doing all this that these branches are completely local. When youâ€™re branching and merging, everything is being done only in your Git repository â€” no server communication is happening.', '2014-10-16 02:16:26');
COMMIT;

SET FOREIGN_KEY_CHECKS = 1;
